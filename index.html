<!DOCTYPE html>
<html>

<head>
  <title>Origin Maker</title>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
  <style>
    #container {
      display: flex;
      /* Use flexbox for layout */
    }

    #blocklyDiv {
      height: 100%px;
      width: 100%px;
      flex: 1;
      /* Allow Blockly to take up available space */
    }

    #outputAreaContainer {
      flex: 1;
      /* Allow output area to take up available space */
      padding: 10px;
      /* Add some padding */
    }

    #outputArea {
      width: 600px;
      height: 600px;
      /* Adjust height as needed */
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="blocklyDiv"></div>
    <div id="outputAreaContainer">
      <textarea id="outputArea" rows="4" cols="50" readonly></textarea>
      <button onclick="copyOutput()">Copy</button>
    </div>
  </div>

  <script>

    function randomnumber() {
      let min = 0;
      let max = 350;
      // Check if the inputs are valid numbers and if min is less than or equal to max.
      if (typeof min !== 'number' || typeof max !== 'number' || min > max) {
        return "Invalid input. Please provide numbers where min <= max.";
      }

      // Generate a random number between 0 (inclusive) and 1 (exclusive).
      const randomNumber = Math.random();

      // Scale and shift the random number to the desired range.
      const randomNumberInRange = Math.floor(randomNumber * (max - min + 1)) + min;

      return randomNumberInRange;
    }
    //POWER
    Blockly.Blocks['power/multiple'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Power( Multiple)")
        this.appendDummyInput()
          .appendField("Name:")
          .appendField(new Blockly.FieldTextInput("NAME"), "NAME") // Name input
        this.appendDummyInput()
          .appendField("Description:")
          .appendField(new Blockly.FieldTextInput("DESCRIPTION"), "DESCRIPTION") // Name input
        this.appendStatementInput("POWER")
          .setCheck(null)
          .appendField("Powers:")
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
        this.setDeletable(false);
      }
    };
    Blockly.Blocks['power/Regular types/attribute_modify_transfer'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Power( Attribute Modify Transfer)")
        this.appendDummyInput()
          .appendField("Power Name:")
          .appendField(new Blockly.FieldTextInput("attribute_modify_transfer"), "NAME") // Name input
        this.appendDummyInput()
          .appendField("Class:")
          .appendField(new Blockly.FieldDropdown([
            ["modify_air_speed", "modify_air_speed"],
            ["modify_break_speed", "modify_break_speed"],
            ["modify_crafting", "modify_crafting"],
            ["modify_damage_dealt", "modify_damage_dealt"],
            ["modify_damage_taken", "modify_damage_taken"],
            ["modify_exhaustion", "modify_exhaustion"],
            ["modify_xp_gain", "modify_xp_gain"],
            ["modify_jump", "modify_jump"],
            ["modify_lava_speed", "modify_lava_speed"],
            ["modify_projectile_damage", "modify_projectile_damage"],
            ["modify_slipperiness", "modify_slipperiness"],
            ["modify_status_effect_amplifier", "modify_status_effect_amplifier"],
            ["modify_status_effect_duration", "modify_status_effect_duration"],
            ["modify_swim_speed", "modify_swim_speed"]
          ]), "CLASS") // Name input
        this.appendDummyInput()
          .appendField("Attribute:")
          .appendField(new Blockly.FieldTextInput("minecraft:generic.movement_speed"), "ATTRIBUTE") // Name input
        this.appendDummyInput()
          .appendField("Multiplier:")
          .appendField(new Blockly.FieldNumber(1.25), "MULTIPLIER") // Name input
        this.appendStatementInput("CONDITIONS")
          .setCheck(null)
          .appendField("Condition:")
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['power/Regular types/attribute'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Power( Attribute)")
        this.appendDummyInput()
          .appendField("Power Name:")
          .appendField(new Blockly.FieldTextInput("attribute"), "NAME") // Name input
        this.appendStatementInput("MODIFIERS")
          .setCheck(null)
          .appendField("Attributed Attribute Modifier( Attributed Attribute Modifier):")
        this.appendDummyInput()
          .appendField("Update Health:")
          .appendField(new Blockly.FieldDropdown([["true", "true"], ["false", "false"]]), "UPDATE_HEALTH") // Name input
        this.appendStatementInput("CONDITIONS")
          .setCheck(null)
          .appendField("Condition:")
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };


    //DATA
    Blockly.Blocks['data/attributed_attribute_modifier'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Data( Attributed Attribute Modifier)")
        this.appendDummyInput()
          .appendField("Operation:")
          .appendField(new Blockly.FieldDropdown([["addition", "addition"], ["multiply_base", "multiply_base"], ["multiply_total", "multiply_total"]]), "OPERATION")
        this.appendDummyInput()
          .appendField("Attribute:")
          .appendField(new Blockly.FieldTextInput("minecraft:generic.movement_speed"), "ATTRIBUTE")
        this.appendDummyInput()
          .appendField("Value:")
          .appendField(new Blockly.FieldNumber(9), "VALUE")
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['data/string'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Data( String)")
          .appendField(new Blockly.FieldTextInput("Enter text here"), "TEXT");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };

    Blockly.Blocks['data/boolean'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Boolean:")
          .appendField(new Blockly.FieldDropdown([["true", "true"], ["false", "false"]]), "BOOL");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };

    Blockly.Blocks['data/number'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Int/Float:")
          .appendField(new Blockly.FieldNumber(0), "NUMBER"); // Use FieldNumber
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber()); // Example color
      }
    };

    //CONDITIONS
    Blockly.Blocks['conditions/Meta Condition Types/and'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions( And):")
        this.appendStatementInput("ITEMS")
          .setCheck(null)
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Meta Condition Types/or'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions( Or):")
        this.appendStatementInput("ITEMS")
          .setCheck(null)
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Entity Condition Types/ability'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions( Ability):")
        this.appendDummyInput()
          .appendField("Ability:")
          .appendField(new Blockly.FieldDropdown([
            ["minecraft:flying", "minecraft:flying"],
            ["minecraft:instabuild", "minecraft:instabuild"],
            ["minecraft:invulnerable", "minecraft:invulnerable"],
            ["minecraft:mayBuild", "minecraft:mayBuild"],
            ["minecraft:mayfly", "minecraft:mayfly"]
          ]), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Entity Condition Types/advancement'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions( Advancement):")
        this.appendDummyInput()
          .appendField("Advancement:")
          .appendField(new Blockly.FieldTextInput("minecraft:story/smelt_iron"), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Meta Condition Types/chance'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions( Chance):")
        this.appendDummyInput()
          .appendField("Chance:")
          .appendField(new Blockly.FieldNumber(1), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Entity Condition Types/air'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions( Air):")
        this.appendDummyInput()
          .appendField("Comparison:")
          .appendField(new Blockly.FieldDropdown([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]]), "COMPARISON")
        this.appendDummyInput()
          .appendField("Compare to:")
          .appendField(new Blockly.FieldNumber(1), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Entity Condition Types/attribute'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions( Attribute):")
        this.appendDummyInput()
          .appendField("Attribute:")
          .appendField(new Blockly.FieldTextInput("minecraft:generic.movement_speed"), "ATTRIBUTE")
        this.appendDummyInput()
          .appendField("Comparison:")
          .appendField(new Blockly.FieldDropdown([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]]), "COMPARISON")
        this.appendDummyInput()
          .appendField("Compare to:")
          .appendField(new Blockly.FieldNumber(1), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Entity Condition Types/biome'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions(Biome):")
        this.appendStatementInput("CONDITION")
          .appendField("Biomes(String):")
          .setCheck(null)
        this.appendStatementInput("BIOMECONDITION")
          .setCheck(null)
          .appendField("Biome Condition( Biome Condition):")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Biome Condition Types/high_humidity'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Biome Conditions( High Humidity):")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Biome Condition Types/temperature'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Biome Conditions( Temperature):")
        this.appendDummyInput()
          .appendField("Comparison:")
          .appendField(new Blockly.FieldDropdown([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]]), "COMPARISON")
        this.appendDummyInput()
          .appendField("Compare to:")
          .appendField(new Blockly.FieldNumber(1), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Biome Condition Types/in_tag'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Biome Conditions( In Tag):")
        this.appendDummyInput()
          .appendField("tag:")
          .appendField(new Blockly.FieldTextInput("minecraft:allows_surface_slime_spawn"), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Biome Condition Types/precipitation'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Biome Conditions( Precipitation):")
        this.appendDummyInput()
          .appendField("precipitation:")
          .appendField(new Blockly.FieldDropdown([["none", "none"], ["rain", "rain"], ["snow", "snow"]]), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Entity Condition Types/block_collision'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Conditions( Block Collision):")
        this.appendStatementInput("CONDITION")
          .setCheck(null)
          .appendField("Block Condition( Block Condition):")
        this.appendDummyInput()
          .appendField("Offset X:")
          .appendField(new Blockly.FieldNumber(1), "OFFSETX")
        this.appendDummyInput()
          .appendField("Offset Y:")
          .appendField(new Blockly.FieldNumber(1), "OFFSETY")
        this.appendDummyInput()
          .appendField("Offset Z:")
          .appendField(new Blockly.FieldNumber(1), "OFFSETZ")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/adjacent'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Adjacent):")
        this.appendStatementInput("BLOCKCONDITION")
          .setCheck(null)
          .appendField("Adjacent Block Condition( Block Condition):")
        this.appendDummyInput()
          .appendField("Comparison:")
          .appendField(new Blockly.FieldDropdown([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]]), "COMPARISON")
        this.appendDummyInput()
          .appendField("Compare to:")
          .appendField(new Blockly.FieldNumber(1), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/attachable'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Attachable):")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/blast_resistance'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Blast Resistance):")
        this.appendDummyInput()
          .appendField("Comparison:")
          .appendField(new Blockly.FieldDropdown([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]]), "COMPARISON")
        this.appendDummyInput()
          .appendField("Compare to:")
          .appendField(new Blockly.FieldNumber(1), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/block_entity'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Block Entity):")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/block_state'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Block State):")
        this.appendDummyInput()
          .appendField("Property:")
          .appendField(new Blockly.FieldTextInput("facing"), "PROPERTY")
        this.appendDummyInput()
          .appendField("Comparison:")
          .appendField(new Blockly.FieldDropdown([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]]), "COMPARISON")
        this.appendDummyInput()
          .appendField("Compare to:")
          .appendField(new Blockly.FieldNumber(1), "CONDITION")
        this.appendDummyInput()
          .appendField("Value:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "VALUE");
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.appendDummyInput()
          .appendField("enum:")
          .appendField(new Blockly.FieldTextInput("north"), "ENUM")
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/block'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Block):")
        this.appendDummyInput()
          .appendField("Block:")
          .appendField(new Blockly.FieldTextInput("minecraft:diamond_block"), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/command'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Command):")
        this.appendDummyInput()
          .appendField("Command:")
          .appendField(new Blockly.FieldTextInput("execute align xyz if entity @e[dy=0,dx=0,dz=0]"), "COMMAND")
        this.appendDummyInput()
          .appendField("Comparison:")
          .appendField(new Blockly.FieldDropdown([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]]), "COMPARISON")
        this.appendDummyInput()
          .appendField("Compare to:")
          .appendField(new Blockly.FieldNumber(1), "CONDITION")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/distance_from_coordinates'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Distance From Coordinates):")
        this.appendDummyInput()
          .appendField("Reference:")
          .appendField(new Blockly.FieldDropdown([["world_origin", "world_origin"], ["world_spawn", "world_spawn"]]), "REFERENCE")
        this.appendDummyInput()
          .appendField("Offset X:")
          .appendField(new Blockly.FieldNumber(0), "OFFSETX")
        this.appendDummyInput()
          .appendField("Offset Y:")
          .appendField(new Blockly.FieldNumber(0), "OFFSETY")
        this.appendDummyInput()
          .appendField("Offset Z:")
          .appendField(new Blockly.FieldNumber(0), "OFFSETZ")
        this.appendDummyInput()
          .appendField("Ignore X:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "IGNOREX");
        this.appendDummyInput()
          .appendField("Ignore Y:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "IGNOREY");
        this.appendDummyInput()
          .appendField("Ignore Z:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "IGNOREZ");
        this.appendDummyInput()
          .appendField("Shape:")
          .appendField(new Blockly.FieldDropdown([["cube", "cube"], ["star", "star"], ["sphere", "sphere"]]), "SHAPE");
        this.appendDummyInput()
          .appendField("Scale Reference To Dimension:")
          .appendField(new Blockly.FieldDropdown([["true", "true"], ["false", "false"]]), "SCALEREFERENCETODIMENSION");
        this.appendDummyInput()
          .appendField("Result On The Wrong Dimension:")
          .appendField(new Blockly.FieldDropdown([["null", "null"], ["true", "true"], ["false", "false"]]), "RESULTONTHEWRONGDIMENSION");
        this.appendDummyInput()
          .appendField("Round to digit:")
          .appendField(new Blockly.FieldNumber(0), "ROUNDTODIGIT")
        this.appendDummyInput()
          .appendField("Comparison:")
          .appendField(new Blockly.FieldDropdown([["<", "<"], ["<=", "<="], [">", ">"], [">=", ">="], ["==", "=="], ["!=", "!="]]), "COMPARISON")
        this.appendDummyInput()
          .appendField("Compare to:")
          .appendField(new Blockly.FieldNumber(1), "COMPARETO")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    Blockly.Blocks['conditions/Block Condition Types/exposed_to_sky'] = {
      init: function () {
        this.appendDummyInput()
          .appendField("Block Conditions( Exposed To Sky):")
        this.appendDummyInput()
          .appendField("Inverted:")
          .appendField(new Blockly.FieldDropdown([["false", "false"], ["true", "true"]]), "INVERTED");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(randomnumber());
      }
    };
    //CONTAINER
    function generateXML(data) {
      let xml = "";
      function generateCategoryXML(categoryName, categoryData) {
        let categoryXML = `<category name="${categoryName}" colour="${randomnumber()}">\n`;
        if (Array.isArray(categoryData)) {
          categoryData.forEach(item => {
            if (typeof item === 'string') { // Check if it's a string (for "Data" case)
              categoryXML += `          <block type="${item}"></block>\n`;
            } else { // Handle nested category objects
              for (const subCategory in item) {
                categoryXML += `          <category name="${subCategory}">\n`;
                item[subCategory].forEach(blockType => {
                  categoryXML += `            <block type="${blockType}"></block>\n`;
                });
                categoryXML += `          </category>\n`;
              }
            }
          });
        } else { //This is for the "data" part which is an array of string
          categoryData.forEach(item => {
            categoryXML += `          <block type="${item}"></block>\n`;
          });
        }
        categoryXML += `        </category>\n`;
        return categoryXML;
      }
      for (const category in data) {
        xml += generateCategoryXML(category, data[category]);
      }
      return xml;
    }
    function getblock(category) {
      let powerlist = [];
      for (const i in Blockly.Blocks) {
        if (i.startsWith(category)) {
          powerlist.push(i);
        }
      }
      return powerlist;
    }
    let menulist = {
      "Power Types": [
        {
          "Regular types": getblock("power/Regular types/")
        },
        { "Action-related": getblock("power/Action-related/") },
        { "Modifying types": getblock("power/Modifying types/") },
        { "Preventing types": getblock("power/Preventing types/") }],
      "Condition": [
        {
          "Meta Condition Types": getblock("conditions/Meta Condition Types/")
        },
        {
          "Entity Condition Types": getblock("conditions/Entity Condition Types/")
        },
        { "Bi-entity Condition Types": getblock("conditions/Bi-entity Condition Types/") },
        {
          "Biome Condition Types": getblock("conditions/Biome Condition Types/")
        },
        { "Block Condition Types": getblock("conditions/Block Condition Types/") },
        { "Damage Condition Types": getblock("conditions/Damage Condition Types/") },
        { "Fluid Condition Types": getblock("conditions/Fluid Condition Types/") },
        { "Item Condition Types": getblock("conditions/Item Condition Types/") }],
      "Data": getblock("data/")
    }
    var workspace = Blockly.inject('blocklyDiv', {
      toolbox: `
      <xml id="toolbox" style="display: none;">
        ${generateXML(menulist)}
      </xml>`,
    });

    //FUNCTIONS
    function placeInitialContainer() {
      var containerBlock = workspace.newBlock('power/multiple');
      containerBlock.initSvg();
      containerBlock.render();
    }

    window.addEventListener('load', placeInitialContainer);

    function updateOutput() {
      let topBlock = workspace.getTopBlocks(true)[0];

      function buildOutput(block) {
        let output = "";
        let POWERoutput = "";
        let CONDITIONSoutput = "";
        while (block) {
          if (block.type === 'data/string') {
            output += `"${block.getFieldValue('TEXT')}" `;
          }
          else if (block.type === 'data/boolean') {
            output += block.getFieldValue('BOOL') + " ";
          }
          else if (block.type === 'data/number') {
            output += block.getFieldValue('NUMBER') + " ";
          }
          //CONDITION
          else if (block.type === 'conditions/Meta Condition Types/and') {
            let ITEMS = block.getInputTargetBlock('ITEMS');
            ITEMS = buildOutput(ITEMS);
            if (ITEMS) {
              if (ITEMS) {
                ITEMS = ITEMS.split(`}{`).filter(item => item !== "").join(`},{`);
              }
              ITEMS = `,"conditions": [${ITEMS}]`;
            } else { ITEMS = `,"conditions": []`; }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:and"${ITEMS}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Meta Condition Types/or') {
            let ITEMS = block.getInputTargetBlock('ITEMS');
            ITEMS = buildOutput(ITEMS);
            if (ITEMS) {
              if (ITEMS) {
                ITEMS = ITEMS.split(`}{`).filter(item => item !== "").join(`},{`);
              }
              ITEMS = `,"conditions": [${ITEMS}]`;
            } else { ITEMS = `,"conditions": []`; }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:or"${ITEMS}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Entity Condition Types/ability') {
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"ability": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:ability"${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Entity Condition Types/advancement') {
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"advancement": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:advancement"${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Meta Condition Types/chance') {
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"chance": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:chance"${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Entity Condition Types/air') {
            let COMPARISON = block.getFieldValue('COMPARISON');
            if (COMPARISON) { COMPARISON = `,"comparison": "${COMPARISON}"`; } else { COMPARISON = "" }
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"compare_to": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:air"${COMPARISON}${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Entity Condition Types/attribute') {
            let ATTRUBUTE = block.getFieldValue('ATTRUBUTE');
            if (ATTRUBUTE) { ATTRUBUTE = `,"attribute": "${ATTRUBUTE}"`; } else { ATTRUBUTE = "" }
            let COMPARISON = block.getFieldValue('COMPARISON');
            if (COMPARISON) { COMPARISON = `,"comparison": "${COMPARISON}"`; } else { COMPARISON = "" }
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"compare_to": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:attribute"${COMPARISON}${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Entity Condition Types/biome') {
            let CONDITION = block.getInputTargetBlock('CONDITION');
            CONDITION = buildOutput(CONDITION);
            if (CONDITION) {
              if (CONDITION) {
                CONDITION = CONDITION.split(`" "`).filter(item => item !== "").join(`", "`);
              }
              CONDITION = `,"biomes": [${CONDITION}]`;
            } else { CONDITION = `,"biomes": []`; }
            let BIOMECONDITION = block.getInputTargetBlock('BIOMECONDITION');
            BIOMECONDITION = buildOutput(BIOMECONDITION);
            if (BIOMECONDITION) {
              if (BIOMECONDITION) {
                BIOMECONDITION = BIOMECONDITION.split(`}"`).filter(item => item !== "").join(`},"`);
              }
              BIOMECONDITION = `,"condition": ${BIOMECONDITION}`;
            }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:biome"${CONDITION}${BIOMECONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Biome Condition Types/high_humidity') {
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:high_humidity"${INVERTED}}`;
          }
          else if (block.type === 'conditions/Biome Condition Types/temperature') {
            let COMPARISON = block.getFieldValue('COMPARISON');
            if (COMPARISON) { COMPARISON = `,"comparison": "${COMPARISON}"`; } else { COMPARISON = "" }
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"compare_to": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:temperature"${COMPARISON}${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Biome Condition Types/in_tag') {
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"tag": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:in_tag"${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Biome Condition Types/precipitation') {
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"tag": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:precipitation"${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Entity Condition Types/block_collision') {
            let CONDITION = block.getInputTargetBlock('CONDITION');
            CONDITION = buildOutput(CONDITION);
            if (CONDITION) {
              if (CONDITION) {
                CONDITION = CONDITION.split(`}"`).filter(item => item !== "").join(`},"`);
              }
              CONDITION = `,"condition": ${CONDITION}`;
            }
            let OFFSETX = block.getFieldValue('OFFSETX');
            if (OFFSETX) { OFFSETX = `,"offset_x": "${OFFSETX}"`; } else { OFFSETX = "" }
            let OFFSETY = block.getFieldValue('OFFSETY');
            if (OFFSETY) { OFFSETY = `,"offset_y": "${OFFSETY}"`; } else { OFFSETY = "" }
            let OFFSETZ = block.getFieldValue('OFFSETZ');
            if (OFFSETZ) { OFFSETZ = `,"offset_z": "${OFFSETZ}"`; } else { OFFSETZ = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:block_collision"${OFFSETX}${OFFSETZ}${OFFSETZ}${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/adjacent') {
            let BLOCKCONDITION = block.getInputTargetBlock('BLOCKCONDITION');
            BLOCKCONDITION = buildOutput(BLOCKCONDITION);
            if (BLOCKCONDITION) {
              if (BLOCKCONDITION) {
                BLOCKCONDITION = BLOCKCONDITION.split(`}"`).filter(item => item !== "").join(`},"`);
              }
              BLOCKCONDITION = `,"adjacent_condition": ${BLOCKCONDITION}`;
            }
            let COMPARISON = block.getFieldValue('COMPARISON');
            if (COMPARISON) { COMPARISON = `,"comparison": "${COMPARISON}"`; } else { COMPARISON = "" }
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"compare_to": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:adjacent"${BLOCKCONDITION}${COMPARISON}${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/attachable') {
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:attachable"${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/blast_resistance') {
            let COMPARISON = block.getFieldValue('COMPARISON');
            if (COMPARISON) { COMPARISON = `,"comparison": "${COMPARISON}"`; } else { COMPARISON = "" }
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"compare_to": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:command"${COMPARISON}${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/block_entity') {
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:block_entity"${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/block') {
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"block": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:block"${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/block_state') {
            let PROPERTY = block.getFieldValue('PROPERTY');
            if (PROPERTY) { PROPERTY = `,"property": "${PROPERTY}"`; } else { PROPERTY = "" }
            let COMPARISON = block.getFieldValue('COMPARISON');
            if (COMPARISON) { COMPARISON = `,"comparison": "${COMPARISON}"`; } else { COMPARISON = "" }
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"compare_to": "${CONDITION}"`; } else { CONDITION = "" }
            let VALUE = block.getFieldValue('VALUE');
            if (VALUE) { VALUE = `,"value": ${VALUE}`; } else { VALUE = "" }
            let ENUM = block.getFieldValue('ENUM');
            if (ENUM) { ENUM = `,"enum": "${ENUM}"`; } else { ENUM = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:block_state"${PROPERTY}${COMPARISON}${CONDITION}${VALUE}${ENUM}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/command') {
            let COMMAND = block.getFieldValue('COMMAND');
            if (COMMAND) { COMMAND = `,"command": "${COMMAND}"`; } else { COMMAND = "" }
            let COMPARISON = block.getFieldValue('COMPARISON');
            if (COMPARISON) { COMPARISON = `,"comparison": "${COMPARISON}"`; } else { COMPARISON = "" }
            let CONDITION = block.getFieldValue('CONDITION');
            if (CONDITION) { CONDITION = `,"compare_to": "${CONDITION}"`; } else { CONDITION = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:command"${COMMAND}${COMPARISON}${CONDITION}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/distance_from_coordinates') {
            let REFERENCE = block.getFieldValue('REFERENCE');
            if (REFERENCE) { REFERENCE = `,"reference": "${REFERENCE}"`; } else { REFERENCE = "" }
            let OFFSETX = block.getFieldValue('OFFSETX');
            let OFFSETY = block.getFieldValue('OFFSETY');
            let OFFSETZ = block.getFieldValue('OFFSETZ');
            let OFFSET = `,"offset":{"x":${OFFSETX},"y":${OFFSETY},"z":${OFFSETZ}}`;
            let IGNOREX = block.getFieldValue('IGNOREX');
            if (IGNOREX) { IGNOREX = `,"ignore_x": ${IGNOREX}`; } else { IGNOREX = "" }
            let IGNOREY = block.getFieldValue('IGNOREY');
            if (IGNOREY) { IGNOREY = `,"ignore_y": ${IGNOREY}`; } else { IGNOREY = "" }
            let IGNOREZ = block.getFieldValue('IGNOREZ');
            if (IGNOREZ) { IGNOREZ = `,"ignore_z": ${IGNOREZ}`; } else { IGNOREZ = "" }
            let SHAPE = block.getFieldValue('SHAPE');
            if (SHAPE) { SHAPE = `,"shape": "${SHAPE}"`; } else { SHAPE = "" }
            let SCALEREFERENCETODIMENSION = block.getFieldValue('SCALEREFERENCETODIMENSION');
            if (SCALEREFERENCETODIMENSION) { SCALEREFERENCETODIMENSION = `,"scale_reference_to_dimension": "${SCALEREFERENCETODIMENSION}"`; } else { SCALEREFERENCETODIMENSION = "" }
            let RESULTONTHEWRONGDIMENSION = block.getFieldValue('RESULTONTHEWRONGDIMENSION');
            if (RESULTONTHEWRONGDIMENSION != "null") { RESULTONTHEWRONGDIMENSION = `,"result_on_the_wrong_dimension": "${RESULTONTHEWRONGDIMENSION}"`; } else { RESULTONTHEWRONGDIMENSION = "" }
            let ROUNDTODIGIT = block.getFieldValue('ROUNDTODIGIT');
            if (ROUNDTODIGIT) { ROUNDTODIGIT = `,"round_to_digit": "${ROUNDTODIGIT}"`; } else { ROUNDTODIGIT = "" }
            let COMPARISON = block.getFieldValue('COMPARISON');
            if (COMPARISON) { COMPARISON = `,"comparison": "${COMPARISON}"`; } else { COMPARISON = "" }
            let COMPARETO = block.getFieldValue('COMPARETO');
            if (COMPARETO) { COMPARETO = `,"compare_to": "${COMPARETO}"`; } else { COMPARETO = "" }
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:distance_from_coordinates"${REFERENCE}${OFFSET}${IGNOREX}${IGNOREY}${IGNOREZ}${SHAPE}${SCALEREFERENCETODIMENSION}${RESULTONTHEWRONGDIMENSION}${ROUNDTODIGIT}${COMPARISON}${COMPARETO}${INVERTED}}`;
          }
          else if (block.type === 'conditions/Block Condition Types/exposed_to_sky') {
            let INVERTED = block.getFieldValue('INVERTED');
            if (INVERTED != "false") { INVERTED = `,"inverted": ${INVERTED}`; } else { INVERTED = "" }
            output += `{"type": "origins:exposed_to_sky"${INVERTED}}`;
          }
          //DATA
          else if (block.type === 'data/attributed_attribute_modifier') {
            let OPERATION = block.getFieldValue('OPERATION');
            if (OPERATION) { OPERATION = `"operation": "${OPERATION}"`; } else { OPERATION = "" }
            let ATTRIBUTE = block.getFieldValue('ATTRIBUTE');
            if (ATTRIBUTE) { ATTRIBUTE = `,"attribute": "${ATTRIBUTE}"`; } else { ATTRIBUTE = "" }
            let VALUE = block.getFieldValue('VALUE');
            if (VALUE) { VALUE = `,"value": ${VALUE}`; } else { VALUE = "" }
            output += `{${OPERATION}${ATTRIBUTE}${VALUE}}`;
          }
          //POWER
          else if (block.type === 'power/multiple') {
            let NAME = block.getFieldValue('NAME');
            if (NAME) { NAME = `,"name": "${NAME}"`; } else { NAME = "" }
            let DESCRIPTION = block.getFieldValue('DESCRIPTION');
            if (DESCRIPTION) { DESCRIPTION = `,"description": "${DESCRIPTION}"`; } else { DESCRIPTION = "" }
            let POWER = block.getInputTargetBlock('POWER');
            POWER = buildOutput(POWER);
            if (POWER) {
              //console.log(POWER)
              POWER = POWER.split(`}"`).filter(item => item !== "").join(`},"`);
              //console.log(POWER)
            }
            output += `{"type": "origins:multiple"${NAME}${DESCRIPTION}, ${POWER}}`;
          }
          else if (block.type === 'power/Regular types/attribute_modify_transfer') {
            let NAME = block.getFieldValue('NAME');
            if (NAME == null) { NAME = `youneedaname`; }
            let CLASS = block.getFieldValue('CLASS');
            if (CLASS) { CLASS = `,"class": "${CLASS}"`; } else { CLASS = "" }
            let ATTRIBUTE = block.getFieldValue('ATTRIBUTE');
            if (ATTRIBUTE) { ATTRIBUTE = `,"attribute": "${ATTRIBUTE}"`; } else { ATTRIBUTE = "" }
            let MULTIPLIER = block.getFieldValue('MULTIPLIER');
            if (MULTIPLIER) { MULTIPLIER = `,"multiplier": "${MULTIPLIER}"`; } else { MULTIPLIER = "" }
            let CONDITIONS = block.getInputTargetBlock('CONDITIONS');
            if (CONDITIONS) {
              CONDITIONS = buildOutput(CONDITIONS);
              if (CONDITIONS) {
                CONDITIONS = CONDITIONS.split(`}"`).filter(item => item !== "").join(`},"`);
              }
              CONDITIONS = `,"condition": ${CONDITIONS}`;
            } else { CONDITIONS = "" }
            output += `"${NAME}":{"type": "origins:attribute_modify_transfer"${CLASS}${ATTRIBUTE}${MULTIPLIER}${CONDITIONS}}`; // Include name and description
          }
          else if (block.type === 'power/Regular types/attribute') {
            let NAME = block.getFieldValue('NAME');
            if (NAME == null) { NAME = `youneedaname`; }
            let UPDATE_HEALTH = block.getFieldValue('UPDATE_HEALTH');
            if (UPDATE_HEALTH) { UPDATE_HEALTH = `,"update_health":"${UPDATE_HEALTH}"`; } else { UPDATE_HEALTH = "" }
            let MODIFIERS = block.getInputTargetBlock('MODIFIERS');
            if (MODIFIERS) {
              MODIFIERS = buildOutput(MODIFIERS);
              if (MODIFIERS) {
                MODIFIERS = MODIFIERS.split(`}"`).filter(item => item !== "").join(`},"`);
              }
              MODIFIERS = `,"modifiers": [${MODIFIERS}]`;
            } else { MODIFIERS = "" }
            let CONDITIONS = block.getInputTargetBlock('CONDITIONS');
            if (CONDITIONS) {
              CONDITIONS = buildOutput(CONDITIONS);
              if (CONDITIONS) {
                CONDITIONS = CONDITIONS.split(`}"`).filter(item => item !== "").join(`},"`);
              }
              CONDITIONS = `,"condition": ${CONDITIONS}`;
            } else { CONDITIONS = "" }

            output += `"${NAME}":{"type": "origins:attribute"${MODIFIERS}${UPDATE_HEALTH}${CONDITIONS}}`;
          }
          block = block.getNextBlock();
        }
        return output;
      }

      output = buildOutput(topBlock).trim()
      //console.log(output)
      try {
        if (output) {
          output = eval("(" + output + ")");
          output = JSON.stringify(output, null, 2)
        }
        //console.log(output)
        document.getElementById('outputArea').value = output;
      } catch (error) {
        document.getElementById('outputArea').value = `Meet Error: ${error}\nOutput:\n${output}`;
      }
    }


    workspace.addChangeListener(updateOutput);

    function copyOutput() {
      var outputText = document.getElementById('outputArea');
      outputText.select();
      outputText.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(outputText.value);
    }

    updateOutput();
  </script>
</body>

</html>