<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chinese Bible Handwriting Practice</title>
    <style>
        :root {
            --primary: #5d4037;
            --bg: #f5f5dc;
            --paper: #fffcf5;
            --accent: #8d6e63;
            --success: #2e7d32;
            --danger: #c62828;
            --download: #1976d2;
        }

        body {
            font-family: "Microsoft JhengHei", sans-serif;
            background-color: var(--bg);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Styles */
        #sidebar {
            position: fixed;
            left: -320px;
            top: 0;
            width: 320px;
            height: 100%;
            background: #fff;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #sidebar.open {
            left: 0;
        }

        #sidebar-header {
            background: var(--primary);
            color: white;
            padding: 15px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #book-list {
            flex: 1;
            overflow-y: auto;
        }

        .book-group {
            border-bottom: 1px solid #eee;
        }

        .book-main {
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            background: #fff;
            transition: background 0.2s;
        }

        .chapter-list {
            display: none;
            background: #f9f9f9;
            padding: 0;
            border-top: 1px solid #eee;
        }

        .book-group.expanded .chapter-list {
            display: block;
        }

        .chapter-item {
            padding: 10px 20px 10px 40px;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            font-size: 0.9em;
            border-bottom: 1px solid #f0f0f0;
        }

        .progress-container {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            transition: width 0.3s;
        }

        .prog-badge {
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
        }

        .arrow {
            font-size: 10px;
            transition: transform 0.3s;
            color: #999;
            margin-left: 5px;
        }

        .book-group.expanded .arrow {
            transform: rotate(90deg);
        }

        .sidebar-footer {
            padding: 10px;
            border-top: 1px solid #eee;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: #fff;
        }

        .footer-btn {
            padding: 10px;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }

        /* Nav Layout */
        nav {
            background: var(--primary);
            padding: 8px;
            display: flex;
            justify-content: center;
            gap: 5px;
            z-index: 10;
            align-items: center;
        }

        nav button {
            padding: 6px 8px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            border: none;
            background: white;
            font-weight: bold;
        }

        .menu-toggle {
            font-size: 16px !important;
        }

        .btn-download-mode {
            background: var(--download);
            color: white;
        }

        #nav-label {
            color: white;
            font-size: 13px;
            font-weight: bold;
            min-width: 70px;
            text-align: center;
        }

        /* Display Area */
        #display-area {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: var(--paper);
        }

        .verse-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 15px;
            position: relative;
        }

        .verse-header {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .verse-number {
            font-weight: bold;
            color: var(--accent);
            font-size: 0.9em;
        }

        /* Checkbox hidden unless in download mode */
        .verse-checkbox {
            display: none;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        body.download-mode .verse-checkbox {
            display: inline-block;
        }

        .char-box {
            display: inline-flex;
            flex-direction: column;
            border: 1px solid #e0e0e0;
            width: 42px;
            background: white;
        }

        .char-box.active {
            border: 3px solid #ff9800 !important;
            background: #fff9c4 !important;
            z-index: 2;
        }

        .original-char {
            font-size: 10px;
            color: #aaa;
            text-align: center;
            background: #fafafa;
            border-bottom: 1px solid #eee;
        }

        .written-img {
            width: 100%;
            height: 38px;
            object-fit: contain;
        }

        /* Writing Area (Hidden in download mode) */
        #writing-area {
            background: #e0e0e0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-top: 2px solid var(--primary);
        }

        body.download-mode #writing-area {
            display: none;
        }

        .writing-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 340px;
            margin-bottom: 8px;
        }

        .side-btn {
            flex: 1;
            height: 60px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            color: white;
            cursor: pointer;
        }

        .btn-clear {
            background: var(--accent);
            margin-right: 10px;
        }

        .btn-submit {
            background: var(--success);
            margin-left: 10px;
        }

        #current-char-display {
            font-size: 42px;
            font-weight: bold;
            background: white;
            width: 75px;
            height: 75px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            border: 2px solid var(--accent);
        }

        #canvas-container {
            background: white;
            border: 2px solid var(--primary);
            touch-action: none;
        }

        /* Download Toolbar */
        #download-toolbar {
            display: none;
            background: #1565c0;
            padding: 10px;
            justify-content: space-around;
        }

        body.download-mode #download-toolbar {
            display: flex;
        }

        #sidebar-overlay {
            position: fixed;
            display: none;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99;
        }
    </style>
</head>

<body>

    <div id="sidebar-overlay" onclick="toggleSidebar()"></div>
    <div id="sidebar">
        <div id="sidebar-header"><span>讀經進度目錄</span><span onclick="toggleSidebar()"
                style="cursor:pointer; font-size: 20px;">✕</span></div>
        <div id="book-list"></div>
        <div class="sidebar-footer">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 5px;">
                <button class="footer-btn" style="background:#607d8b" onclick="exportBackup()">匯出備份 (Export)</button>
                <button class="footer-btn" style="background:#9e9e9e" onclick="triggerImport()">匯入備份 (Import)</button>
            </div>
            <input type="file" id="importFile" style="display:none" onchange="importBackup(event)" accept=".json">
            <button class="footer-btn" style="background:var(--accent)" onclick="clearChapter()">清空本章記錄</button>
            <button class="footer-btn" style="background:var(--danger)" onclick="clearAll()">清空全體歷史</button>
        </div>
    </div>

    <nav id="main-nav">
        <button class="menu-toggle" onclick="toggleSidebar()">☰</button>
        <button onclick="changeBook(-1)">上卷</button>
        <button onclick="changeChapter(-1)">上章</button>
        <span id="nav-label">...</span>
        <button onclick="changeChapter(1)">下章</button>
        <button onclick="changeBook(1)">下卷</button>
        <button class="btn-download-mode" onclick="toggleDownloadMode()">下載</button>
    </nav>

    <div id="download-toolbar">
        <button class="footer-btn" style="background:#fff; color:#1565c0;" onclick="toggleDownloadMode()">取消</button>
        <button class="footer-btn" style="background:#ff9800; color:#fff;" onclick="selectAllVerses()">全選 (Select
            All)</button>
        <button class="footer-btn" style="background:#4caf50; color:#fff;" onclick="exportSelected()">導出選中節次
            (Export)</button>
    </div>

    <div id="display-area">
        <h2 id="book-title" style="text-align:center; color:var(--primary); font-size:1.1em; margin:0 0 10px 0;">載入中...
        </h2>
        <div id="verses-container"></div>
    </div>

    <div id="writing-area">
        <div class="writing-header">
            <button class="side-btn btn-clear" onclick="clearCanvas()">清除<br>(Clear)</button>
            <div id="current-char-display">?</div>
            <button class="side-btn btn-submit" onclick="saveWriting()">提交<br>(OK)</button>
        </div>
        <div id="canvas-container"><canvas id="paintCanvas" width="280" height="280"></canvas></div>
    </div>

    <script>
        let books = [];
        let currentBookIndex = 0;
        let currentChapter = 1;
        let chapterData = [];
        let activeGlobalIndex = 0;
        let isDownloadMode = false;

        // IndexedDB variables
        const DB_NAME = "BiblePracticeDB";
        const DB_VERSION = 1;
        const STORE_NAME = "handwriting";
        let db;

        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
                request.onsuccess = (e) => {
                    db = e.target.result;
                    resolve();
                };
                request.onerror = (e) => reject("IndexedDB error");
            });
        }

        // NEW: Helper to get/set data from IndexedDB
        function getDB(key) {
            return new Promise((resolve) => {
                const transaction = db.transaction([STORE_NAME], "readonly");
                const request = transaction.objectStore(STORE_NAME).get(key);
                request.onsuccess = () => resolve(request.result);
            });
        }

        function setDB(key, val) {
            return new Promise((resolve) => {
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const request = transaction.objectStore(STORE_NAME).put(val, key);
                request.onsuccess = () => resolve();
            });
        }

        function deleteDB(key) {
            return new Promise((resolve) => {
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const request = transaction.objectStore(STORE_NAME).delete(key);
                request.onsuccess = () => resolve();
            });
        }
        async function init() {
            try {
                await initDB(); // Wait for DB to be ready
                const res = await fetch('https://bible.helloao.org/api/cmn_cuv/books.json');
                const data = await res.json();
                books = data.books;

                // Retrieve last session from IndexedDB (or fallback to localStorage for migration)
                const lastSession = await getDB('bible_last_session') || JSON.parse(localStorage.getItem('bible_last_session'));

                if (lastSession) {
                    currentBookIndex = lastSession.bookIndex;
                    currentChapter = lastSession.chapter;
                }

                loadChapter();
                setupCanvas();
            } catch (e) {
                console.error("Initialization error:", e);
            }
        }

        function toggleDownloadMode() {
            isDownloadMode = !isDownloadMode;
            document.body.classList.toggle('download-mode', isDownloadMode);
            document.getElementById('main-nav').style.display = isDownloadMode ? 'none' : 'flex';
            renderDisplay();
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            const isOpen = sidebar.classList.toggle('open');
            overlay.style.display = isOpen ? 'block' : 'none';
            if (isOpen) renderSidebar();
        }

        function getProgColor(perc) {
            const r = Math.floor(255 - (perc * 2.55));
            const g = Math.floor(perc * 2.55);
            return `rgb(${r},${g},0)`;
        }

        async function renderSidebar() {
            const list = document.getElementById('book-list');
            list.innerHTML = "";
            const chapterMeta = await getDB('bible_meta') || {};

            for (let bIdx = 0; bIdx < books.length; bIdx++) {
                const book = books[bIdx];
                const group = document.createElement('div');
                group.className = 'book-group';

                let completedChapters = 0;
                for (let c = 1; c <= book.numberOfChapters; c++) {
                    const key = `bible_${book.id}_${c}`;
                    const data = await getDB(key) || {};
                    if (chapterMeta[key] && Object.keys(data).length >= chapterMeta[key]) completedChapters++;
                }

                const bookPerc = Math.round((completedChapters / book.numberOfChapters) * 100);
                const main = document.createElement('div');
                main.className = 'book-main';
                main.innerHTML = `<div style="display:flex; align-items:center;"><span class="arrow">▶</span><span style="margin-left:8px;">${book.name}</span></div><span class="prog-badge" style="background:${getProgColor(bookPerc)}">${bookPerc}%</span>`;

                main.onclick = () => {
                    const isExpanded = group.classList.contains('expanded');
                    document.querySelectorAll('.book-group').forEach(g => g.classList.remove('expanded'));
                    if (!isExpanded) group.classList.add('expanded');
                };

                const cList = document.createElement('div');
                cList.className = 'chapter-list';
                for (let c = 1; c <= book.numberOfChapters; c++) {
                    const key = `bible_${book.id}_${c}`;
                    const cData = await getDB(key) || {};
                    const writtenCount = Object.keys(cData).length;
                    const totalInChap = chapterMeta[key] || 0;
                    const chapPerc = totalInChap > 0 ? Math.round((writtenCount / totalInChap) * 100) : 0;

                    const cItem = document.createElement('div');
                    cItem.className = 'chapter-item';
                    cItem.innerHTML = `<div class="chapter-info"><span>第 ${c} 章</span><span style="font-size:10px;">${writtenCount}/${totalInChap || '?'}字 (${chapPerc}%)</span></div><div class="progress-container"><div class="progress-bar" style="width:${chapPerc}%; background:${getProgColor(chapPerc)}"></div></div>`;
                    cItem.onclick = (e) => { e.stopPropagation(); currentBookIndex = bIdx; currentChapter = c; toggleSidebar(); loadChapter(); };
                    cList.appendChild(cItem);
                }
                group.appendChild(main);
                group.appendChild(cList);
                list.appendChild(group);
            }
        }

        async function loadChapter() {
            const book = books[currentBookIndex];
            const key = `bible_${book.id}_${currentChapter}`;

            await setDB('bible_last_session', { bookIndex: currentBookIndex, chapter: currentChapter });

            document.getElementById('nav-label').innerText = `${book.shortName || book.name} ${currentChapter}`;
            document.getElementById('book-title').innerText = `${book.name} 第 ${currentChapter} 章`;

            const res = await fetch(`https://bible.helloao.org/api/cmn_cuv/${book.id}/${currentChapter}.json`);
            const data = await res.json();

            chapterData = [];
            let totalChars = 0;
            data.chapter.content.forEach(v => {
                if (v.type === "verse") {
                    let text = "";
                    v.content.forEach(line => text += (typeof line === 'string' ? line : line.text));
                    const chars = text.match(/[\u4e00-\u9fa5，。；：！？（）「」『』、]/g) || [];
                    chapterData.push({ number: v.number, chars: chars });
                    totalChars += chars.length;
                }
            });

            const chapterMeta = await getDB('bible_meta') || {};
            chapterMeta[key] = totalChars;
            await setDB('bible_meta', chapterMeta);

            activeGlobalIndex = 0;
            renderDisplay();
            updateTargetChar();
        }

        async function renderDisplay() {
            const container = document.getElementById('verses-container');
            container.innerHTML = "";
            const storageKey = `bible_${books[currentBookIndex].id}_${currentChapter}`;
            const history = await getDB(storageKey) || {};
            let globalIdx = 0;

            chapterData.forEach((verse, vIdx) => {
                const verseRow = document.createElement('div');
                verseRow.className = 'verse-row';

                const vHeader = document.createElement('div');
                vHeader.className = 'verse-header';
                vHeader.innerHTML = `<input type="checkbox" class="verse-checkbox" data-vidx="${vIdx}"><span class="verse-number">第 ${verse.number} 節</span>`;
                verseRow.appendChild(vHeader);

                verse.chars.forEach((char) => {
                    const thisIdx = globalIdx;
                    const box = document.createElement('div');
                    box.className = 'char-box' + (thisIdx === activeGlobalIndex && !isDownloadMode ? ' active' : '');
                    box.id = `char-${thisIdx}`;

                    // Logic: Only show the img tag if there is actual history data
                    const hasData = !!history[thisIdx];
                    box.innerHTML = `
                <span class="original-char">${char}</span>
                <img class="written-img" src="${hasData ? history[thisIdx] : ''}" 
                     style="display: ${hasData ? 'block' : 'none'};">
            `;

                    if (!isDownloadMode) {
                        box.onclick = () => { activeGlobalIndex = thisIdx; updateHighlight(); updateTargetChar(); };
                    }
                    verseRow.appendChild(box);
                    globalIdx++;
                });
                container.appendChild(verseRow);
            });
        }

        function selectAllVerses() {
            const checkboxes = document.querySelectorAll('.verse-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
        }

        async function exportSelected() {
    const selectedCheckboxes = document.querySelectorAll('.verse-checkbox:checked');
    if (selectedCheckboxes.length === 0) { alert("請先選取要導出的節次！"); return; }

    const storageKey = `bible_${books[currentBookIndex].id}_${currentChapter}`;
    const history = await getDB(storageKey) || {};

    // A4 Constants for 300 DPI
    const A4_WIDTH = 2480;
    const A4_HEIGHT = 3508;
    const CHARS_PER_LINE = 20;
    const CHAR_SIZE = 100; // High quality size
    const LINE_SPACING = 60;
    const MARGIN = 100;
    const HEADER_SPACE = 200;
    
    const rowHeight = CHAR_SIZE + LINE_SPACING;
    const availableHeight = A4_HEIGHT - (MARGIN * 2) - HEADER_SPACE;

    let currentY = 0;
    let pageCount = 1;
    let tempCanvas = document.createElement('canvas');
    let tempCtx = tempCanvas.getContext('2d');

    const setupNewPage = (canvas, ctx, pNum) => {
        canvas.width = A4_WIDTH;
        canvas.height = A4_HEIGHT;
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, A4_WIDTH, A4_HEIGHT);
        
        // Header info
        ctx.fillStyle = "#5d4037";
        ctx.font = "bold 60px Microsoft JhengHei";
        ctx.textAlign = "center";
        ctx.fillText(`${books[currentBookIndex].name} - 第 ${currentChapter} 章 (第 ${pNum} 頁)`, A4_WIDTH / 2, MARGIN + 60);
        ctx.textAlign = "left";
        return HEADER_SPACE;
    };

    const downloadPage = (canvas, pNum) => {
        const link = document.createElement('a');
        link.download = `${books[currentBookIndex].name}_Chap${currentChapter}_Page${pNum}.png`;
        link.href = canvas.toDataURL("image/png", 1.0);
        link.click();
    };

    const getGlobalIdx = (vIdx) => {
        let count = 0;
        for (let i = 0; i < vIdx; i++) count += chapterData[i].chars.length;
        return count;
    };

    currentY = setupNewPage(tempCanvas, tempCtx, pageCount);

    for (let i = 0; i < selectedCheckboxes.length; i++) {
        const vIdx = parseInt(selectedCheckboxes[i].dataset.vidx);
        const verse = chapterData[vIdx];
        const linesNeeded = Math.ceil(verse.chars.length / CHARS_PER_LINE);
        const verseHeight = 40 + (linesNeeded * rowHeight) + 40; // Verse label + chars + padding

        // Check if verse fits on current page
        if (currentY + verseHeight > A4_HEIGHT - MARGIN) {
            downloadPage(tempCanvas, pageCount);
            pageCount++;
            currentY = setupNewPage(tempCanvas, tempCtx, pageCount);
        }

        // Draw Verse Label
        tempCtx.fillStyle = "#8d6e63";
        tempCtx.font = "bold 40px Microsoft JhengHei";
        tempCtx.fillText(`第 ${verse.number} 節`, MARGIN, currentY + 40);
        currentY += 60;

        let gIdx = getGlobalIdx(vIdx);
        for (let c = 0; c < verse.chars.length; c++) {
            const lineNum = Math.floor(c / CHARS_PER_LINE);
            const colNum = c % CHARS_PER_LINE;
            
            const posX = MARGIN + (colNum * (CHAR_SIZE + 10));
            const posY = currentY + (lineNum * rowHeight);

            // Draw Grid
            tempCtx.strokeStyle = "#d7ccc8";
            tempCtx.lineWidth = 2;
            tempCtx.strokeRect(posX, posY, CHAR_SIZE, CHAR_SIZE);

            const charImgData = history[gIdx + c];
            if (charImgData) {
                const img = new Image();
                img.src = charImgData;
                await new Promise(r => img.onload = r);
                tempCtx.drawImage(img, posX, posY, CHAR_SIZE, CHAR_SIZE);
            }
        }
        currentY += (linesNeeded * rowHeight) + 40;
    }

    // Download the last (or only) page
    downloadPage(tempCanvas, pageCount);
}

        // Standard Handwriting Setup
        function updateHighlight() {
            document.querySelectorAll('.char-box').forEach(box => box.classList.remove('active'));
            const activeBox = document.getElementById(`char-${activeGlobalIndex}`);
            if (activeBox) { activeBox.classList.add('active'); activeBox.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        }
        function updateTargetChar() {
            const allChars = chapterData.flatMap(v => v.chars);
            document.getElementById('current-char-display').innerText = allChars[activeGlobalIndex] || "完";
        }
        function setupCanvas() {
            ctx.lineWidth = 9; ctx.lineCap = 'round'; ctx.strokeStyle = '#000';
            const getPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
                const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
                return { x: clientX - rect.left, y: clientY - rect.top };
            };
            const start = (e) => { isDrawing = true; draw(e); };
            const end = () => { isDrawing = false; ctx.beginPath(); };
            const draw = (e) => { if (!isDrawing) return; if (e.cancelable) e.preventDefault(); const pos = getPos(e); ctx.lineTo(pos.x, pos.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(pos.x, pos.y); };
            canvas.addEventListener('mousedown', start); canvas.addEventListener('mousemove', draw); window.addEventListener('mouseup', end);
            canvas.addEventListener('touchstart', start, { passive: false }); canvas.addEventListener('touchmove', draw, { passive: false }); canvas.addEventListener('touchend', end);
        }
        function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }
        async function saveWriting() {
            const storageKey = `bible_${books[currentBookIndex].id}_${currentChapter}`;
            const history = await getDB(storageKey) || {};

            // Create a temporary canvas to add a white background
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Fill white background (prevents black JPEG issue)
            tempCtx.fillStyle = "#FFFFFF";
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Draw your writing on top of the white
            tempCtx.drawImage(canvas, 0, 0);

            const imgData = tempCanvas.toDataURL("image/jpeg", 0.5);

            history[activeGlobalIndex] = imgData;
            await setDB(storageKey, history);

            // Update the UI immediately
            const activeBox = document.getElementById(`char-${activeGlobalIndex}`);
            const activeBoxImg = activeBox.querySelector('.written-img');
            if (activeBoxImg) {
                activeBoxImg.src = imgData;
                activeBoxImg.style.display = 'block'; // Show it now that it has data
            }

            clearCanvas();
            activeGlobalIndex++;
            updateHighlight();
            updateTargetChar();
        }
        function changeBook(dir) { currentBookIndex = Math.max(0, Math.min(books.length - 1, currentBookIndex + dir)); currentChapter = 1; loadChapter(); }
        function changeChapter(dir) { const book = books[currentBookIndex]; const newChap = currentChapter + dir; if (newChap >= 1 && newChap <= book.numberOfChapters) { currentChapter = newChap; loadChapter(); } }
        async function clearChapter() {
            if (confirm("清除本章記錄？")) {
                await deleteDB(`bible_${books[currentBookIndex].id}_${currentChapter}`);
                renderDisplay();
            }
        }

        async function clearAll() {
            if (confirm("警告：這將刪除所有書寫歷史及進度！")) {
                const transaction = db.transaction([STORE_NAME], "readwrite");
                transaction.objectStore(STORE_NAME).clear();
                renderDisplay();
                activeGlobalIndex = 0;
                updateTargetChar();
            }
        }

        async function exportBackup() {
            const transaction = db.transaction([STORE_NAME], "readonly");
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();
            const keysRequest = store.getAllKeys();

            request.onsuccess = () => {
                const backupData = {};
                keysRequest.onsuccess = () => {
                    keysRequest.result.forEach((key, i) => {
                        backupData[key] = request.result[i];
                    });
                    const dataStr = JSON.stringify(backupData);
                    const blob = new Blob([dataStr], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'bible_full_backup.json';
                    link.click();
                };
            };
        }
        function triggerImport() {
            document.getElementById('importFile').click();
        }
        async function importBackup(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                const importedData = JSON.parse(e.target.result);
                if (confirm("這將覆蓋現有所有進度，確定要匯入嗎？")) {
                    const transaction = db.transaction([STORE_NAME], "readwrite");
                    const store = transaction.objectStore(STORE_NAME);
                    store.clear();
                    for (const key in importedData) {
                        store.put(importedData[key], key);
                    }
                    alert("匯入成功！");
                    location.reload();
                }
            };
            reader.readAsText(file);
        }
        init();
    </script>
</body>

</html>