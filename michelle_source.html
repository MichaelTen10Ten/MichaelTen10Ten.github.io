<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Live2D Michelle with VITS Umamusume TTS + Poe Chat</title>
    <style>
        body {
            display: flex;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            flex-direction: row;
            /* Desktop default */
        }

        /* On small screens, stack vertically */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #chat-container {
                width: 100% !important;
                height: 50vh;
                border-left: none;
                border-top: 1px solid #ccc;
            }

            #live2d-container {
                height: 50vh;
            }
        }

        #live2d-container {
            flex: 1;
            background: #f0f8ff;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #chat-container {
            width: 380px;
            display: flex;
            flex-direction: column;
            padding: 15px;
            background: #fff;
            border-left: 1px solid #ccc;
        }

        #chat-history {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            background: #fafafa;
            border-radius: 6px;
        }

        .message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 12px;
            max-width: 85%;
        }

        .user {
            background: #007bff;
            color: white;
            align-self: flex-end;
        }

        .bot {
            background: #e9ecef;
            color: #333;
            align-self: flex-start;
        }

        input,
        button {
            width: 100%;
            padding: 10px;
            margin: 6px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            background: #28a745;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #218838;
        }

        #status {
            color: #555;
            font-size: 0.9em;
            margin-top: 5px;
            text-align: center;
        }

        #model-error {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: red;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            display: none;
        }

        #mic-btn.recording {
            background: #dc3545 !important;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }
    </style>

    <!-- Live2D scripts -->
    <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.4.2/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/RaSan147/pixi-live2d-display@v0.5.0-ls-8/dist/cubism4.min.js"></script>
</head>

<body>

    <div id="live2d-container">
        <canvas id="canvas"></canvas>
        <div id="model-error">Live2D model failed to load. Check console & file path.</div>
    </div>
    <div id="chat-container">
        <div id="chat-history"></div>
        <input id="api-key" type="password" placeholder="Paste your Poe API Key here">

        <div style="display: flex; gap: 5px;">
            <input id="question" type="text" placeholder="Ask a question..." style="flex: 1;">
            <button id="mic-btn" style="width: 50px; background: #6c757d;">ðŸŽ¤</button>
        </div>

        <button onclick="sendQuestion()">Send</button>
        <div id="status">TTS: Using Plachta VITS Umamusume (cute female Japanese voice)</div>
    </div>
    <script>
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Live2D Setup
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let model;
        async function initLive2D() {
            const canvas = document.getElementById('canvas');

            app = new PIXI.Application({
                view: canvas,
                autoStart: true,
                resizeTo: document.getElementById('live2d-container'), // Resize to parent div
                backgroundColor: 0xf0f8ff,
                antialias: true,
                autoDensity: true,
                resolution: window.devicePixelRatio || 1
            });

            const modelPath = 'source/michelle_source/simple.model3.json';

            try {
                model = await PIXI.live2d.Live2DModel.from(modelPath);
                app.stage.addChild(model);

                // This function handles the scaling so it doesn't crop
                const fitModel = () => {
                    if (!model) return;

                    // Calculate scale to fit the container (adjust 0.9 to change "zoom")
                    const scaleX = (app.screen.width / model.width) * 0.8;
                    const scaleY = (app.screen.height / model.height) * 0.8;
                    const finalScale = Math.min(scaleX, scaleY);

                    model.scale.set(finalScale);

                    // Center the model
                    model.anchor.set(0.5, 0.5);
                    model.position.set(app.screen.width / 2, app.screen.height / 1.5);
                };

                // Call once on load
                fitModel();

                // Call every time the window resizes
                app.renderer.on('resize', fitModel);

                model.autoInteract = true;
            } catch (err) {
                console.error("Live2D load failed:", err);
                document.getElementById('model-error').style.display = 'block';
            }
        }
        function resizeCanvas() {
            if (!app || !model) return;

            const container = document.getElementById('live2d-container');
            const screenWidth = container.clientWidth;
            const screenHeight = container.clientHeight;
            const targetRatio = 16 / 9;

            let newWidth, newHeight;

            // Calculate dimensions to fit 16:9 inside the container
            if (screenWidth / screenHeight > targetRatio) {
                newHeight = screenHeight;
                newWidth = screenHeight * targetRatio;
            } else {
                newWidth = screenWidth;
                newHeight = screenWidth / targetRatio;
            }

            // Resize the renderer
            app.renderer.resize(newWidth, newHeight);

            // Reposition the model relative to the NEW canvas size
            model.scale.set(1); // Adjust this base scale as needed
            model.anchor.set(0.5, 0.5);
            model.position.set(newWidth / 2, newHeight * 0.6);
        }
        window.addEventListener('resize', resizeCanvas);
        initLive2D().catch(err => console.error(err));

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Chat & System prompt (force English output)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const messages = [{
            role: "system",
            content: `You are a cute girl named Michelle.
You are Created by Michael Ten.
Always reply in English only, no matter what language the user uses.
Be natural, friendly, and a little playful.
Always start your reply with [lang:en-US] followed by the content.`
        }];

        const chatHistory = document.getElementById('chat-history');

        function addMessage(role, content) {
            const div = document.createElement('div');
            div.classList.add('message', role);
            div.textContent = content;
            chatHistory.appendChild(div);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Mouth animation
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let mouthInterval = null;

        function startMouthAnimation() {
            if (mouthInterval) clearInterval(mouthInterval);
            let phase = 0;
            mouthInterval = setInterval(() => {
                if (!model?.internalModel?.coreModel) return;
                const value = 0.2 + Math.abs(Math.sin(phase)) * 0.9;
                model.internalModel.coreModel.setParameterValueById('PARAM_MOUTH_OPEN_Y', value);
                phase += 0.65;
            }, 45);
        }

        function stopMouthAnimation() {
            if (mouthInterval) {
                clearInterval(mouthInterval);
                mouthInterval = null;
            }
            if (model?.internalModel?.coreModel) {
                model.internalModel.coreModel.setParameterValueById('PARAM_MOUTH_OPEN_Y', 0);
            }
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // TTS: Fetch All Chunks First, Then Play
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        async function speak(text) {
            if (typeof text !== 'string' || !text.trim()) return;

            // 1. Break text into chunks (sentences) to prevent API timeouts
            const chunks = splitTextIntoChunks(text, 100); // 100 chars is a safe limit for this API
            console.log(`Split into ${chunks.length} chunks. Fetching audio...`);

            try {
                // 2. Fetch all audio URLs in parallel
                const audioUrlPromises = chunks.map(chunk => fetchAudioUrl(chunk));
                const audioUrls = await Promise.all(audioUrlPromises);

                // 3. Play them in sequence
                console.log("All audio fetched. Starting playback...");
                for (const url of audioUrls) {
                    if (url) {
                        await playAudio(url);
                    }
                }
            } catch (err) {
                console.error("Batch TTS failed, falling back to browser voice:", err);
                fallbackBrowserTTS(text);
            }
        }

        // Helper: Split text by punctuation (. ! ?)
        function splitTextIntoChunks(text, maxLength) {
            // Regex splits by . ! or ? but keeps the punctuation with the sentence
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
            const chunks = [];
            let currentChunk = "";

            sentences.forEach(sentence => {
                if ((currentChunk + sentence).length < maxLength) {
                    currentChunk += sentence;
                } else {
                    if (currentChunk) chunks.push(currentChunk.trim());
                    currentChunk = sentence;
                }
            });
            if (currentChunk) chunks.push(currentChunk.trim());
            return chunks;
        }

        // Helper: Fetch a single audio URL from Gradio
        async function fetchAudioUrl(text) {
            const base_url = "https://plachta-vits-umamusume-voice-synthesizer.hf.space/gradio_api/call/tts_fn";
            const payload = {
                data: [text, "ç‰¹åˆ«å‘¨ Special Week (Umamusume Pretty Derby)", "English", 0.75, false]
            };

            const submitRes = await fetch(base_url, {
                method: 'POST',
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            const { event_id } = await submitRes.json();

            const pollRes = await fetch(`${base_url}/${event_id}`);
            const pollText = await pollRes.text();

            // Extract URL from the SSE (Server Sent Events) response
            const match = pollText.match(/"url":\s*"(https:\/\/[^"]+)"/);
            if (match && match[1]) return match[1];
            throw new Error("Could not find audio URL in response");
        }

        // Helper: Play audio and return promise that resolves when finished
        function playAudio(url) {
            return new Promise((resolve, reject) => {
                const audio = new Audio(url);
                audio.crossOrigin = "anonymous";
                audio.onplay = startMouthAnimation;
                audio.onended = () => {
                    stopMouthAnimation();
                    resolve();
                };
                audio.onerror = (e) => {
                    stopMouthAnimation();
                    reject(e);
                };
                audio.play().catch(reject);
            });
        }

        // Helper: Browser Fallback
        function fallbackBrowserTTS(text) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = "en-US";
            utterance.pitch = 1.85;
            utterance.rate = 1.15;
            utterance.onstart = startMouthAnimation;
            utterance.onend = stopMouthAnimation;
            speechSynthesis.speak(utterance);
        }
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Send question
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        async function sendQuestion() {
            const apiKey = document.getElementById('api-key').value.trim();
            if (!apiKey) { alert('è«‹è¼¸å…¥ Poe API Key'); return; }

            const question = document.getElementById('question').value.trim();
            if (!question) return;

            addMessage('user', question);
            document.getElementById('question').value = '';

            messages.push({ role: 'user', content: question });

            try {
                const res = await fetch('https://api.poe.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({ model: 'gpt-4o-mini', messages, stream: false })
                });

                if (!res.ok) throw new Error(`Poe API ${res.status}`);

                const data = await res.json();
                let fullReply = data?.choices?.[0]?.message?.content?.trim?.() || '';

                let replyText = fullReply;
                const langMatch = fullReply.match(/^\[lang:([a-zA-Z-]+)\]/i);
                if (langMatch) replyText = fullReply.replace(langMatch[0], '').trim();


                await speak(replyText);
                addMessage('bot', replyText);
                messages.push({ role: 'assistant', content: fullReply });

            } catch (err) {
                console.error(err);
                addMessage('bot', 'å‡ºå’—å•é¡Œâ€¦è«‹æª¢æŸ¥ API key æˆ–ç¶²çµ¡');
            }
        }

        window.sendQuestion = sendQuestion;
        document.getElementById('question').addEventListener('keypress', e => {
            if (e.key === 'Enter') { e.preventDefault(); sendQuestion(); }
        });

        // Debug voices
        speechSynthesis.onvoiceschanged = () => {
            const voices = speechSynthesis.getVoices();
            const cantonese = voices.filter(v => v.lang === "zh-HK");
            if (cantonese.length) console.log("Browser zh-HK voices:", cantonese.map(v => v.name));
        };
        speechSynthesis.getVoices();

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Speech to Text (STT) Setup
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const micBtn = document.getElementById('mic-btn');
        const questionInput = document.getElementById('question');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        if (SpeechRecognition) {
            const recognition = new SpeechRecognition();
            recognition.lang = 'en-US'; // You can change this to 'zh-HK' or 'ja-JP'
            recognition.interimResults = false;
            recognition.continuous = false;

            micBtn.addEventListener('click', () => {
                try {
                    recognition.start();
                } catch (e) {
                    recognition.stop();
                }
            });

            recognition.onstart = () => {
                micBtn.classList.add('recording');
                micBtn.textContent = 'ðŸ›‘';
                questionInput.placeholder = "Listening...";
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                questionInput.value = transcript;
                // Automatically send the question after voice input
                sendQuestion();
            };

            recognition.onend = () => {
                micBtn.classList.remove('recording');
                micBtn.textContent = 'ðŸŽ¤';
                questionInput.placeholder = "Ask a question...";
            };

            recognition.onerror = (event) => {
                console.error("Speech Recognition Error: ", event.error);
                micBtn.classList.remove('recording');
                micBtn.textContent = 'ðŸŽ¤';
            };
        } else {
            micBtn.style.display = 'none';
            console.warn("Speech Recognition not supported in this browser.");
        }
    </script>
</body>

</html>